В решении будет использоваться знание следующих характеристик: следующими характеристиками:
доставка сообщений не гарантируется, доставленные сообщения не искажаются, сообщения могут 
дублироваться, сохранение порядка при приеме сообщений не гарантируется, все получаемые 
сообщения были кем-то отправлены, каждое сообщение рано или поздно достигнет получателя, если отправитель будет повторять 
попытки передать сообщение.

### At-most-once

Заметим, что единственная проблема, которая нам грозит - это дублирование сообщений.
Таким образом нам нужно возложить роль знаний о дубликатах одному из узлов.
В данном решении посчиталось наиболее разумным хранить эту информацию у Receiver,
так как иначе придется делать "долгие" сессии подтверждений назад. 
Для этого мы реализуем интерфейс очереди, пользуясь условностью, 
что вероятность того, что дубликаты придут с большой разницей во времени крайне мала.

### At-least-once

В данном случае проблема уже заключается только в том, что сообщение могло не дойти. 
По причинам, аналогичным тем, что описаны выше, запрашивать подтверждение у Receiver каждый 
раз было бы слишком расточительно по ресурсам. 
По этому следует хранить необходимые данные и выполнять основную логику подтверждения у Sender.

В свою очередь Sender хранит в очереди все сообщения, к которым еще не получил подтверждение. 
А также ставит таймер, чтобы периодически отправлять еще раз неподтвержденные сообщения.

### Exactly-once

Так как прошлые два пункта содержат основную логику в двух разных узлах
(At-most-once в Receiver, а At-least-once в Sender). 
А также объединение их гарантий является гарантией для данного пункта, 
то используется объединение вышесказанных подходов. Однако для того, чтобы оптимизировать 
использование памяти у Receiver, используется оптимизация: 
Sender отправляет не все неподтвержденные сообщения, а только несколько.

### Exactly-once-ordered 

Для того чтобы все сообщения в конечном итоге дошли используем логику описанную в At-least-once.
Однако, для того чтобы бороться с дубликатами, 
а также использовать упорядоченность, используем другой подход.
Будем хранить индекс сообщения, который мы ждем сейчас. А для сообщений 
с индексами больше указанного подтверждение посылать не будем.

В качестве оптимизации можно хранить у Receiver некоторое количество сообщений
с наименьшими индексами, из тех, что мы получили от Sender. И таким образом пользуясь 
условностью, что сообщения не очень далеко уходят от своих позиций в порядке,
в котором они должны идти (в идеальной системе), мы можем достаточно часто отправлять уже
сохраненные сообщения, когда придет их очередь. При этом нам не будет необходимо 
дожидаться их повторной отправки от Sender.
