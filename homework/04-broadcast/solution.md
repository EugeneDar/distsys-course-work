## Описание алгоритма

### Хранимые значения

Каждый процесс помимо своего id и id всех процессов хранит также некоторые
служебные поля, для выполнения всех необходимых гарантий.

Хранимые значения:
1. Счетчик числа полученных сообщений.
2. Сет уникальных id разосланных сообщений.
3. Сет уникальных id сообщений полученных от пользователей.
4. Сет уникальных id сообщений доставленных пользователю.
5. Словарь из уникальных id сообщений, которые мы хотим доставить, в два элемента: 
число процессов, от которых мы получили данное сообщение, и само сообщение.

### Метод `on_local_message`

Создаём уникальный id сообщения, рассылаем это сообщение всем кроме себя.
Добавляем его во все коллекции, кроме сета уникальных id доставленных сообщений.

### Метод `try_deliver_messages`

Проходим по списку всех сообщений, которые мы хотим отправить.
Проверяем, что мы имеем достаточное количество этого сообщения от других процессов.
Проверяем, что мы доставили все необходимые до этого сообщения.
Если проверки прошли, то доставляем сообщение, кладем его в сет доставленных и удаляем из списка желаемых.

### Метод `on_message`

Выходим, если уже отравляли это сообщение.

Обновляем количество этого сообщения от других процессов.
Если ранее мы это сообщение не рассылали, то выполняем рассылку.

Пытаемся доставить какое-то из сообщений, если смогли доставить что-то, то повторяем попытку.

## Обоснование достижения требуемых свойств

### `No Duplication`

Дупликация сообщений не может произойти, так как мы отслеживаем доставленные сообщения.

### `No Creation`

Канал сам по себе надежный, и мы сами по себе также не создаем новых сообщений.

### `Validity`

Заметим, что сообщение будет доставлено, если выполнены два условия:
мы получили это сообщение хотя бы от половины процессов,
мы доставили необходимые для причинного порядка сообщения.

Если процесс корректен, то в конечном счёте он получит подтверждение больше чем от половины процессов,
так как отказать может только меньшинство.
Причинный порядок будет выполнен сразу, так как отправитель сам его и задаёт.

### `Uniform Agreement`

Если сообщение было доставлено некоторым процессом, значит оно получило его в последствии от большинства процессов.
Значит все корректные процессы получат это сообщение от большинства процессов.

Получаем: для того чтобы они его отправили им нужно до этого доставить все предыдущие по причинному порядку.
И мы видим, что для доставки этих предыдущих сообщений выполняются такие же правила. Поэтому по индукции 
мы видим, что в конце концов все сообщения будут доставлены.

Краткое пояснение индукции: будет сообщения, которому не нужно предыдущих, так как оно было первым,
его отправка разрешит отправку ненулевого числа других сообщений и так далее. Так мы и доходим до 
разрешения на отправку сообщения, которое рассматривали изначально.

### `Causal Order`

В начале рассылки каким-то процессов мы просто добавляем в рассылку информацию о всех сообщениях, которые
отправитель уже успел получить или доставить. И в дальнейшем доставляем сообщение другим процессом,
только если мы уже доставили все необходимые сообщения.

## Оптимизации

### Сохранение корректности при росте числа узлов

#### Проблемы

Заметим, что при росте числа узлов, если не внести дополнительных изменений, то свойства указанные выше
могут перестать выполняться. Рассмотрим в чем конкретно заключается проблема.

Свойства `No Duplication` и `No Creation` все еще выполняются по схожим соображениям.

Для трёх оставшихся свойств попробуем внести такие изменения,
чтобы все условия выполнялись для определенного сообщения в том случае, если корректными остались 
более половины процессов из тех, которые были в системе на момент начала рассылки данного сообщения.
Также сами гарантии на каждое конкретное сообщение сделаем применимыми только для процессов, которые
уже были в системе на момент начала рассылки.

#### Обновлённые свойства

1. `No Duplication`: без изменений.
2. `No Creation`: без изменений.
3. `Validity`: без изменений.
4. `Uniform Agreement`: Если сообщение m было доставлено некоторым процессом (необязательно корректным),
то m будет в конце концов доставлено каждым корректным процессом, который был в системе
на момент начала рассылки m.
5. `Causal Order`: без изменений.

Для свойств 3-5 присутствует дополнительное условие, что они выполняются для сообщения m,
если из процессов присутствовавших в системе на момент начала его рассылки большинство корректные.

#### Необходимые изменения

Отправитель теперь будет каждый раз добавлять список процессов, которые присутствуют в системе на
момент начала рассылки. Также если в процессе рассылки было получено сообщение процессом, которого
нет в данном списке, то он его игнорирует.

Заметим, что в таком случае на условия `No Duplication`, `No Creation`, `Causal Order` не накладывается 
никаких изменений, так что они продолжают выполняться по причинам описанным для системы без
масштабируемости.

`Validity` теперь будет выполняться исходя из того, что мы будем ждать число не больше половины от 
общего числа процессов, как раньше, а больше половины от числа процессов, которые указаны в списке.
Причинный порядок выполнен отправителем сразу.

`Uniform Agreement` аналогично соблюдает свойство с обновленным "правилом половины".
Причинный порядок продолжает выполняться, так как система для определенного сообщения
по сути продолжает действовать изолированно от новых процессов.

### Уменьшение размера хранимой информации

#### Проблема

Заметим, что основная проблема - это то, что множества уникальных id сообщений 
(у нас таких множества три) не чистятся со временем, а только растут в размере. Придумаем свободы как
со временем очищать данные множества.

#### Изменение

Для всех множеств этот способ будет одинаковый. Воспользуемся тем, что по своей структуре id сообщения 
состоит из id процесса, который начал рассылку, и из порядкового номера получения этого сообщения.
Тогда будем вместо множества id хранить словарь из номера процесса в множество интервалов id, которые в
нём присутствуют. 

#### Доказательство оптимизации

Сразу отметим, что оба способа хранения (старый и новый) содержат одинаковое количество
информации про хранимые id. Также отметим заранее, что для отказавшего процесса размер хранимых данных перестанет
расти, так что в дальнейшем мы рассматриваем корректные процессы.

Теперь покажем почему это всё-таки оптимизация. Число элементов словаря увеличивается только при увеличении числа
процессов. Покажем, что размер самих элементов не будет бесконечно расти. Воспользуемся свойством `Uniform Agreement`,
а также предположением,
что время отправки сообщения между парой процессов a и b не меняется постоянно в неограниченных пределах.
Заметим, что интервалы не пересекаются. Пусть у нас есть два соседних интервала `[l1, r1]` и `[l2, r2]`. Тогда в конечном
итоге из-за свойства `Uniform Agreement` они либо заполнят промежуток между собой и смогут объединиться в одни интервал,
либо указанный процесс отправитель откажет и запись в множество вовсе прекратится.

Таким образом со временем мы будем уменьшать число ранее созданных интервалов. Почему прирост их числа не будет
быстрее убывания? Это уже следствие предположения, что время посылок в среднем лежит в каком-то диапазоне и 
если нам пришло новое сообщение, то более старое уже пришло или придет в ближайшее время.

Важное замечание: размер хранимой информации в зависимости от числа сообщений может вырасти до любого масштаба,
однако в конечном итоге мы все равно его сократим за счёт заполнения пропусков. Также отметим, что если всё-же
время отправки сообщения между парой процессов a и b будет меняться слишком кардинально, то мы будем хранить сопоставимое
старому способу количество данных.
